构思算法的实现过程。
①先来先服务算法
一开始我从最简单的先来先服务开始想，既然要排序进程链表的执行顺序，肯定要将链表的头head作为参数传入到方法中。其次为了之后方便一次性检验多种算法，传入进来的head链表我不会对它进行任何改变。所以创建一个新链表head2用CreateHead方法将链表进行复制，这样我就可以拿head2这个复制品随便搞，也不会影响之后调用其他算法，因为head没变。
当我拿到复制链表head2之后，要对他进行先来先服务算法排序，肯定要比较所有进程的到达时间，从到达时间最小的进程先开始执行，需要注意的是将某个进程执行完毕之后，要将它从链表中移除，以确保下一次查找的正确性。所以我用一个大循环，循环次数是链表的结点数，每一次循环都找到本次循环到达时间最小的那个结点，然后将这个结点的所有进程信息进行更新，包括完成时间，周转时间，带权周转时间，打印所有的信息到控制台。并且更新一下总时间线start(一开始为0，每次运行一个进程，它的值都加上这个进程的运行时间，相当于总时间线）。最后将这个结点从链表中删除，再次循环从剩余的节点中找到达时间最小的结点，直到所有结点都被删除了。那么所有结点的执行顺序也已经全部被打印到控制台上了。每次循环都记录周转时间和带权周转时间。最后循环结束计算一下平均值。下面是算法流程图：

②短作业优先算法
短作业优先自然要选择运行时间最短的进程先执行，和上面的算法流程图大体一致，就是要找出链表中运行时间最短的节点。并且要注意的是如果最短运行时间的进程的到达时间很迟，而有一个运行时间较长的进程先到达了，就不能让CPU等着。应该先执行到达的进程，等到这个进程执行完毕之后，再次找运行时间最短的进程。直到程序退出。

③高优先级优先算法
高优先级和前两种也类似，主要是找到最高优先级的进程先运行，而且也要和第二种算法一样注意进程的到达时间。

④高响应比优先算法
此算法和前三种稍有不同，虽然大体流程相同，但是响应比有自己的计算公式，响应比 = （等待时间+要求服务时间）/ 要求服务时间。
我封装了一个方法专门求响应比，所以也可以和上面三种程序一样先找到响应比最高的进程运行。需要注意的是，每一个进程运行完毕之后响应比都会发生变化。

⑤时间片轮转算法
这个算法我想它大体是个先来先服务一样的，所以我将所有进程一开始按到达时间排序，因为每次时间片执行完毕进程不一定结束，所以给进程的节点中添加两个新属性int newarrival和int newruntime用来保存更新之后的到达时间和运行时间，每次时间片执行完毕，这个进程的到达时间就是此刻，然后将它的到达时间和链表中所有的进程的到达时间进行比较，插入它比它小和比它大的到达时间之间，如果遇到相等的到达时间就插入到本来存在节点的后面。然后本次时间片结束，头指针向后移动运行下一个排队的进程节点。
————————————————
版权声明：本文为CSDN博主「程序瑶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_39487033/article/details/85940336

 调度类型：
1。批处理调度、分时调度、实时调度和多处理机调度
2。长程调度、中程调度、短程调度
3。I／O调度

长程调度：
    作业调度（从外存调度到内存），创建了进程后，可能等待短程调度和中程调度。
    两个问题：
    1。选择多少个作业进入内存（取决于多道程序的度）
    2。选择哪些作业（取决于长程调度算法）

中程调度：挂起状态进程的调度
    目的是提高内存利用率和系统吞吐量  

【我们最关注的需要研究的调度算法】
短程调度：进程调度，低级调度
       哪些情况会发生短程调度？IO中断，时钟中断，系统调用，信号发生机制